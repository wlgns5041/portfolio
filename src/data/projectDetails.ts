import type { ProjectItem } from "../components/modals/ProjectDetailModal";

export const projectDetails: Record<string, ProjectItem["detail"]> = {
  portfolio: {
    statusLabel: "서비스 중",
    duration: "2025.12",
    team: "개인 프로젝트",
    contribution: ["개발 100%", "디자인 100%", "기획 100%", "배포 100%"],

    intro: `TypeScript + React + Tailwind CSS로 개발한 웹 기반 개인 포트폴리오입니다.
단순 정적 페이지가 아니라 “프로덕트처럼 운영 가능한 포트폴리오”를 목표로, 컴포넌트 단위 설계/타입 안정성/성능/배포까지 전체 흐름을 직접 구성했습니다.`,

    features: [
      "섹션 기반 구성(소개/스킬/경험/프로젝트/연락처) + 스크롤 네비게이션",
      "프로젝트 상세 모달(이미지 갤러리 + PDF 뷰어/다운로드) 제공",
      "반응형 레이아웃 + 인터랙션 애니메이션(Framer Motion)으로 몰입감 강화",
      "Vercel 배포 및 운영 환경 구성(도메인 연결/빌드 파이프라인)",
    ],

    techReasons: `
                • TypeScript
                포트폴리오는 시간이 지나며 섹션/데이터 구조가 계속 변경되기 때문에, props·데이터 모델 변경 시 런타임에서 오류가 발생하기 쉽습니다.
                ProjectItem, ProjectDetail 등 도메인 타입을 먼저 정의해 데이터 구조를 고정하고,
                컴포넌트 간 계약(Props)을 타입으로 관리함으로써 리팩터링 시 안정성을 확보했습니다.

                또한 모달, 프로젝트 상세 화면처럼 UI 상태가 복잡한 영역에서도
                잘못된 타입 전달을 컴파일 단계에서 차단할 수 있어 유지보수성이 크게 향상되었습니다.

                • Tailwind CSS
                페이지 전반에 카드, 배지, 버튼, 모달, 그라데이션 등 공통 UI 패턴이 반복되기 때문에
                전통적인 CSS 방식에서는 스타일 스코프 충돌과 관리 비용이 빠르게 증가할 수 있었습니다.

                Tailwind의 유틸리티 기반 접근 방식을 통해 디자인 토큰을 일관되게 유지하고,
                컴포넌트 단위로 동일한 규칙을 확장할 수 있어 선택했습니다.
                빠른 프로토타이핑 이후 고정 UI 컴포넌트로 정리하는 흐름에서도 높은 생산성을 보였습니다.

                • React
                섹션 단위 레이아웃 분리와 모달, 탭, 스크롤 기반 인터랙션을 상태로 관리하기에
                React의 컴포넌트 구조가 적합했습니다.

                • Framer Motion

                Framer Motion은 모달 오픈·클로즈, 스크롤 기반 애니메이션을
                CSS만으로 구현할 때 발생하는 복잡도를 줄이고,
                motion value 기반의 자연스러운 전환을 구현할 수 있어 채택했습니다.

                • Vercel
                정적 배포에 최적화되어 있으며,
                PR 단위 Preview 배포, 빌드 로그 확인, 환경변수 관리가 간편해
                운영 관점에서 비용 대비 효율이 가장 높다고 판단했습니다.
                `,

    issues: [
      {
        problem:
          "스크롤/모달/애니메이션이 결합된 화면에서 잦은 state 업데이트가 발생하며, 일부 구간에서 리렌더가 과도해져 체감 성능이 떨어지는 문제가 발생",
        solution:
          "스크롤 위치를 state로 직접 저장하기보다 Framer Motion의 motion value(useScroll/useTransform)로 UI 변화를 처리해 React state 업데이트를 최소화했습니다. 또한 모달 내부를 key 기반으로 리마운트하여(프로젝트 전환 시) 불필요한 상태 누적을 차단했고, 프로젝트별 activeIdx를 map 형태로 관리해 컴포넌트 책임을 분리했습니다.",
      },
      {
        problem:
          "프로젝트 상세에서 PDF 렌더링 시, pdfjs worker 버전 불일치 및 큰 용량(PDF 66MB) 파일에서 렌더링이 흰 화면으로 보이거나 로딩 실패가 발생",
        solution:
          "react-pdf와 pdfjs-dist 버전 불일치를 정리하고(worker 경로는 public 기반으로 안정적으로 제공), 모달 내 렌더링은 1차로 첫 페이지 우선 렌더 후 점진 로딩하도록 구성했습니다. 또한 파일 자체 용량이 큰 경우를 대비해 ‘새 탭에서 열기’/다운로드 경로를 함께 제공해 UX fallback을 만들었습니다.",
      },
      {
        problem:
          "초기 번들 크기 증가(이미지/아이콘/모달/애니메이션 포함)로 첫 진입 체감 속도가 느려질 가능성",
        solution:
          "섹션/모달 단위로 코드 스플리팅(React.lazy/Suspense)을 적용하고, 이미지 리소스는 lazy loading 및 적절한 사이즈로 관리해 초기 렌더 비용을 분산했습니다. 결과적으로 첫 화면에 필요한 리소스만 우선 로드하도록 구성했습니다.",
      },
    ],

    takeaway: `기능 구현보다 구조, 상태 흐름, 렌더 비용을 먼저 설계해야 서비스가 안정적으로 유지된다는 것을 경험했습니다.
               이후에는 기능 추가 시에도 확장성과 유지보수를 기준으로 설계하는 습관을 갖게 되었습니다.`,

    highlights: [
      "도메인 타입(ProjectItem/Detail) 기반 설계로 리팩터링 안정성 확보",
      "스크롤/애니메이션 처리에서 motion value 중심으로 state 업데이트 최소화",
      "PDF 로딩/worker 이슈 트러블슈팅 + 대용량 파일 대응 UX fallback 구성",
      "코드 스플리팅/리소스 로딩 전략으로 초기 진입 비용 분산",
      "Vercel 배포/도메인 연결로 운영 가능한 형태로 서비스화",
    ],
  },
};